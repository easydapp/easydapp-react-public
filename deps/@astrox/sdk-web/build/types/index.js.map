{"version":3,"sources":["../../../src/types/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ActorSubclass, HttpAgent, SignIdentity } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { AccountIdentifier, Memo } from '../utils/common/types';\nimport { DelegationChain, DelegationIdentity } from '@dfinity/identity';\nimport { AbstractedClientStorage, Wallet } from '@astrox/sdk-core';\nimport { IC } from '../ic';\n\nexport type DelegationMode = 'global' | 'domain';\n\nexport interface IIDelegationResult {\n  delegation: {\n    pubkey: Uint8Array;\n    expiration: bigint;\n    targets?: Principal[];\n  };\n  signature: Uint8Array;\n}\n\nexport interface DelegationMessage {\n  kind: string;\n  delegations: IIDelegationResult[];\n  userPublicKey: Uint8Array;\n}\n\nexport interface HandleDelegationResult {\n  delegationChain: DelegationChain;\n  delegationIdentity: DelegationIdentity;\n}\n\nexport interface AbstractConnection<T> {\n  identity: SignIdentity;\n  delegationIdentity: DelegationIdentity;\n  actor?: ActorSubclass<T>;\n  agent?: HttpAgent;\n  canisterId?: string;\n  getActor(): Promise<ActorSubclass<T>>;\n}\n\nexport interface CreateActorResult<T> {\n  actor: ActorSubclass<T>;\n  agent: HttpAgent;\n}\n\nexport interface SendOpts {\n  fee?: bigint;\n  memo?: Memo | Array<number>;\n  from_subaccount?: Array<number>;\n  created_at_time?: Date;\n}\n\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n  /**\n   * An identity to use as the base\n   */\n  identity?: SignIdentity;\n  /**\n   * Optional storage with get, set, and remove. Uses SessionStorage by default\n   */\n  storage?: AbstractedClientStorage;\n  // appId\n  appId?: string;\n  whitelistApi?: string;\n  whitelistCanister?: string;\n  idpWindowOption?: string;\n}\n\nexport interface AuthClientLoginOptions extends AuthClientCreateOptions {\n  /**\n   * Identity provider. By default, use the identity service.\n   */\n  authType?: AuthClientType;\n\n  identityProvider?: string | URL;\n\n  permissions?: PermissionsType[];\n  delegationTargets?: string[];\n  whitelist?: string[];\n  host?: string;\n  noUnify?: boolean;\n  delegationModes?: Array<DelegationMode>;\n  customDomain?: string;\n  /**\n   * Experiation of the authentication\n   */\n  maxTimeToLive?: bigint;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: () => void | Promise<void>;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: (error?: string) => void;\n\n  /**\n   * Callback once is authenticated\n   */\n  onAuthenticated?: (ic: IC) => void | Promise<void>;\n}\n\nexport interface ConnectOptions extends AuthClientLoginOptions {\n  ledgerCanisterId?: string;\n  ledgerHost?: string;\n  walletProviderUrl?: string;\n  signerProviderUrl?: string;\n  dev?: boolean;\n  useFrame?: boolean;\n}\n\nexport interface BaseTransaction {\n  /**\n   * Identity provider. By default, use the identity service.\n   */\n  walletProvider?: string | URL;\n  sendOpts: SendOpts;\n  maxTimeout?: number;\n  successTimeout?: number;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: (value?: any) => void | Promise<void>;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: (error?: string) => void;\n  from?: AccountIdentifier;\n  to: AccountIdentifier;\n  standard: string;\n}\n\nexport interface TransactionToken extends BaseTransaction {\n  amount?: bigint;\n  symbol: string;\n}\n\nexport interface TransactionNFT extends BaseTransaction {\n  tokenIndex?: number;\n  canisterId?: string;\n  tokenIdentifier?: string;\n}\n\nexport type TransactionOptions = TransactionNFT | TransactionToken;\n\nexport interface SignerOptions {\n  /**\n   * Identity provider. By default, use the identity service.\n   */\n  signerProvider?: string | URL;\n  from?: AccountIdentifier;\n  message: Uint8Array | string; //\n  maxTimeout?: number;\n  successTimeout?: number;\n  /**\n   * Callback once login has completed\n   */\n  onSuccess?: (value?: any) => void | Promise<void>;\n  /**\n   * Callback in case authentication fails\n   */\n  onError?: (error?: string) => void;\n}\n\nexport type AuthClientType = 'authorize-client' | 'authorize-append';\n\nexport interface InternetIdentityAuthRequest {\n  kind: AuthClientType;\n  sessionPublicKey: Uint8Array;\n  permissions?: PermissionsType[];\n  delegationTargets?: string[];\n  delegationModes?: Array<DelegationMode>;\n  noUnify?: boolean;\n  maxTimeToLive?: bigint;\n  appId?: string;\n  host?: string;\n}\n\nexport interface AuthRequestJSON {\n  lastRequest: {\n    maxTimeToLive: string;\n    kind: AuthClientType;\n    sessionPublicKey: Uint8Array;\n    permissions?: PermissionsType[];\n    delegationTargets?: string[];\n    noUnify?: boolean;\n    appId?: string;\n  };\n  confirm: boolean;\n}\n\nexport interface DelegationResult {\n  delegations: {\n    delegation: {\n      pubkey: Uint8Array;\n      expiration: bigint;\n      targets?: string[];\n    };\n    signature: Uint8Array;\n  }[];\n  userPublicKey: Uint8Array;\n}\n\nexport interface MeAuthResponseSuccess {\n  kind: 'authorize-client-success';\n  identity: DelegationResult;\n  confirm?: boolean;\n  wallet?: Wallet;\n}\n\nexport interface IIAuthResponseSuccess extends DelegationResult {\n  kind: 'authorize-client-success';\n}\n\nexport type AuthResponseSuccess = MeAuthResponseSuccess | IIAuthResponseSuccess;\n\nexport type EventHandler = (event: MessageEvent) => Promise<void>;\n\nexport enum PermissionsType {\n  identity = 'permissions-identity',\n  wallet = 'permissions-wallet',\n}\n\nexport enum SignerMessageKind {\n  client = 'signer-client',\n  ready = 'signer-ready',\n  success = 'signer-client-success',\n  fail = 'signer-client-failure',\n}\n\nexport interface SignerReadyMessage {\n  kind: SignerMessageKind.ready;\n}\n\nexport interface SignerResponseFailure {\n  kind: SignerMessageKind.fail;\n  text: string;\n}\n\nexport interface SignerResponseFailure {\n  kind: SignerMessageKind.fail;\n  text: string;\n}\n\nexport interface SignerResponseSuccess {\n  kind: SignerMessageKind.success;\n  payload?: {\n    publicKey: string;\n    signature: string;\n    originPayload: {\n      message: Uint8Array;\n    };\n  };\n}\n\nexport type SignerResponseMessage = SignerReadyMessage | SignerResponse;\nexport type SignerResponse = SignerResponseSuccess | SignerResponseFailure;\n\n// Transaction Types\nexport enum TransactionMessageKind {\n  client = 'transaction-client',\n  ready = 'transaction-ready',\n  success = 'transaction-client-success',\n  fail = 'transaction-client-failure',\n}\n\nexport interface TransactionReadyMessage {\n  kind: TransactionMessageKind.ready;\n}\n\nexport interface TransactionResponseFailure {\n  kind: TransactionMessageKind.fail;\n  text: string;\n}\n\nexport interface TransactionResponseSuccess {\n  kind: TransactionMessageKind.success;\n  payload?: {\n    blockHeight: bigint;\n    originPayload: {\n      to: AccountIdentifier;\n      amount: bigint;\n      sendOpts?: Partial<SendOpts>;\n    };\n  };\n}\n\nexport type TransactionResponseMessage = TransactionReadyMessage | TransactionResponse;\nexport type TransactionResponse = TransactionResponseSuccess | TransactionResponseFailure;\n\nexport interface AuthReadyMessage {\n  kind: 'authorize-ready';\n}\n\nexport interface AuthResponseFailure {\n  kind: 'authorize-client-failure';\n  text: string;\n}\n\nexport type IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\nexport type AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n"],"names":["PermissionsType","SignerMessageKind","TransactionMessageKind"],"mappings":"AA4NA,OAAO,IAAA,AAAKA,yCAAAA;;;WAAAA;MAGX;AAED,OAAO,IAAA,AAAKC,2CAAAA;;;;;WAAAA;MAKX;AA+BD,OAAO,IAAA,AAAKC,gDAAAA;;;;;WAAAA;MAKX"}