{"version":3,"sources":["../../../src/types/index.d.ts"],"sourcesContent":["import { ActorSubclass, HttpAgent, SignIdentity } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { AccountIdentifier, Memo } from '../utils/common/types';\nimport { DelegationChain, DelegationIdentity } from '@dfinity/identity';\nimport { AbstractedClientStorage, Wallet } from '@astrox/sdk-core';\nimport { IC } from '../ic';\nexport declare type DelegationMode = 'global' | 'domain';\nexport interface IIDelegationResult {\n    delegation: {\n        pubkey: Uint8Array;\n        expiration: bigint;\n        targets?: Principal[];\n    };\n    signature: Uint8Array;\n}\nexport interface DelegationMessage {\n    kind: string;\n    delegations: IIDelegationResult[];\n    userPublicKey: Uint8Array;\n}\nexport interface HandleDelegationResult {\n    delegationChain: DelegationChain;\n    delegationIdentity: DelegationIdentity;\n}\nexport interface AbstractConnection<T> {\n    identity: SignIdentity;\n    delegationIdentity: DelegationIdentity;\n    actor?: ActorSubclass<T>;\n    agent?: HttpAgent;\n    canisterId?: string;\n    getActor(): Promise<ActorSubclass<T>>;\n}\nexport interface CreateActorResult<T> {\n    actor: ActorSubclass<T>;\n    agent: HttpAgent;\n}\nexport interface SendOpts {\n    fee?: bigint;\n    memo?: Memo | Array<number>;\n    from_subaccount?: Array<number>;\n    created_at_time?: Date;\n}\n/**\n * List of options for creating an {@link AuthClient}.\n */\nexport interface AuthClientCreateOptions {\n    /**\n     * An identity to use as the base\n     */\n    identity?: SignIdentity;\n    /**\n     * Optional storage with get, set, and remove. Uses SessionStorage by default\n     */\n    storage?: AbstractedClientStorage;\n    appId?: string;\n    whitelistApi?: string;\n    whitelistCanister?: string;\n    idpWindowOption?: string;\n}\nexport interface AuthClientLoginOptions extends AuthClientCreateOptions {\n    /**\n     * Identity provider. By default, use the identity service.\n     */\n    authType?: AuthClientType;\n    identityProvider?: string | URL;\n    permissions?: PermissionsType[];\n    delegationTargets?: string[];\n    whitelist?: string[];\n    host?: string;\n    noUnify?: boolean;\n    delegationModes?: Array<DelegationMode>;\n    customDomain?: string;\n    /**\n     * Experiation of the authentication\n     */\n    maxTimeToLive?: bigint;\n    /**\n     * Callback once login has completed\n     */\n    onSuccess?: () => void | Promise<void>;\n    /**\n     * Callback in case authentication fails\n     */\n    onError?: (error?: string) => void;\n    /**\n     * Callback once is authenticated\n     */\n    onAuthenticated?: (ic: IC) => void | Promise<void>;\n}\nexport interface ConnectOptions extends AuthClientLoginOptions {\n    ledgerCanisterId?: string;\n    ledgerHost?: string;\n    walletProviderUrl?: string;\n    signerProviderUrl?: string;\n    dev?: boolean;\n    useFrame?: boolean;\n}\nexport interface BaseTransaction {\n    /**\n     * Identity provider. By default, use the identity service.\n     */\n    walletProvider?: string | URL;\n    sendOpts: SendOpts;\n    maxTimeout?: number;\n    successTimeout?: number;\n    /**\n     * Callback once login has completed\n     */\n    onSuccess?: (value?: any) => void | Promise<void>;\n    /**\n     * Callback in case authentication fails\n     */\n    onError?: (error?: string) => void;\n    from?: AccountIdentifier;\n    to: AccountIdentifier;\n    standard: string;\n}\nexport interface TransactionToken extends BaseTransaction {\n    amount?: bigint;\n    symbol: string;\n}\nexport interface TransactionNFT extends BaseTransaction {\n    tokenIndex?: number;\n    canisterId?: string;\n    tokenIdentifier?: string;\n}\nexport declare type TransactionOptions = TransactionNFT | TransactionToken;\nexport interface SignerOptions {\n    /**\n     * Identity provider. By default, use the identity service.\n     */\n    signerProvider?: string | URL;\n    from?: AccountIdentifier;\n    message: Uint8Array | string;\n    maxTimeout?: number;\n    successTimeout?: number;\n    /**\n     * Callback once login has completed\n     */\n    onSuccess?: (value?: any) => void | Promise<void>;\n    /**\n     * Callback in case authentication fails\n     */\n    onError?: (error?: string) => void;\n}\nexport declare type AuthClientType = 'authorize-client' | 'authorize-append';\nexport interface InternetIdentityAuthRequest {\n    kind: AuthClientType;\n    sessionPublicKey: Uint8Array;\n    permissions?: PermissionsType[];\n    delegationTargets?: string[];\n    delegationModes?: Array<DelegationMode>;\n    noUnify?: boolean;\n    maxTimeToLive?: bigint;\n    appId?: string;\n    host?: string;\n}\nexport interface AuthRequestJSON {\n    lastRequest: {\n        maxTimeToLive: string;\n        kind: AuthClientType;\n        sessionPublicKey: Uint8Array;\n        permissions?: PermissionsType[];\n        delegationTargets?: string[];\n        noUnify?: boolean;\n        appId?: string;\n    };\n    confirm: boolean;\n}\nexport interface DelegationResult {\n    delegations: {\n        delegation: {\n            pubkey: Uint8Array;\n            expiration: bigint;\n            targets?: string[];\n        };\n        signature: Uint8Array;\n    }[];\n    userPublicKey: Uint8Array;\n}\nexport interface MeAuthResponseSuccess {\n    kind: 'authorize-client-success';\n    identity: DelegationResult;\n    confirm?: boolean;\n    wallet?: Wallet;\n}\nexport interface IIAuthResponseSuccess extends DelegationResult {\n    kind: 'authorize-client-success';\n}\nexport declare type AuthResponseSuccess = MeAuthResponseSuccess | IIAuthResponseSuccess;\nexport declare type EventHandler = (event: MessageEvent) => Promise<void>;\nexport declare enum PermissionsType {\n    identity = \"permissions-identity\",\n    wallet = \"permissions-wallet\"\n}\nexport declare enum SignerMessageKind {\n    client = \"signer-client\",\n    ready = \"signer-ready\",\n    success = \"signer-client-success\",\n    fail = \"signer-client-failure\"\n}\nexport interface SignerReadyMessage {\n    kind: SignerMessageKind.ready;\n}\nexport interface SignerResponseFailure {\n    kind: SignerMessageKind.fail;\n    text: string;\n}\nexport interface SignerResponseFailure {\n    kind: SignerMessageKind.fail;\n    text: string;\n}\nexport interface SignerResponseSuccess {\n    kind: SignerMessageKind.success;\n    payload?: {\n        publicKey: string;\n        signature: string;\n        originPayload: {\n            message: Uint8Array;\n        };\n    };\n}\nexport declare type SignerResponseMessage = SignerReadyMessage | SignerResponse;\nexport declare type SignerResponse = SignerResponseSuccess | SignerResponseFailure;\nexport declare enum TransactionMessageKind {\n    client = \"transaction-client\",\n    ready = \"transaction-ready\",\n    success = \"transaction-client-success\",\n    fail = \"transaction-client-failure\"\n}\nexport interface TransactionReadyMessage {\n    kind: TransactionMessageKind.ready;\n}\nexport interface TransactionResponseFailure {\n    kind: TransactionMessageKind.fail;\n    text: string;\n}\nexport interface TransactionResponseSuccess {\n    kind: TransactionMessageKind.success;\n    payload?: {\n        blockHeight: bigint;\n        originPayload: {\n            to: AccountIdentifier;\n            amount: bigint;\n            sendOpts?: Partial<SendOpts>;\n        };\n    };\n}\nexport declare type TransactionResponseMessage = TransactionReadyMessage | TransactionResponse;\nexport declare type TransactionResponse = TransactionResponseSuccess | TransactionResponseFailure;\nexport interface AuthReadyMessage {\n    kind: 'authorize-ready';\n}\nexport interface AuthResponseFailure {\n    kind: 'authorize-client-failure';\n    text: string;\n}\nexport declare type IdentityServiceResponseMessage = AuthReadyMessage | AuthResponse;\nexport declare type AuthResponse = AuthResponseSuccess | AuthResponseFailure;\n"],"names":[],"mappings":"AAkQA,WAA6E"}