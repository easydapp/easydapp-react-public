{"version":3,"sources":["../../../src/ic/icAuthClient.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/no-non-null-asserted-optional-chain */\nimport { AnonymousIdentity, DerEncodedPublicKey, Identity, Signature, SignIdentity } from '@dfinity/agent';\nimport { Principal } from '@dfinity/principal';\nimport { Delegation, DelegationChain, DelegationIdentity, Ed25519KeyIdentity, isDelegationValid } from '@dfinity/identity';\nimport {\n  AuthClientCreateOptions,\n  AuthClientLoginOptions,\n  AuthRequestJSON,\n  AuthResponseSuccess,\n  DelegationResult,\n  EventHandler,\n  IdentityServiceResponseMessage,\n  InternetIdentityAuthRequest,\n  MeAuthResponseSuccess,\n  PermissionsType,\n} from '../types';\nimport {\n  IDENTITY_PROVIDER_DEFAULT,\n  IDENTITY_PROVIDER_ENDPOINT,\n  KEY_ICSTORAGE_DELEGATION,\n  KEY_ICSTORAGE_KEY,\n  KEY_ICSTORAGE_WALLET,\n  ICStorage,\n  _deleteStorage,\n  KEY_DELEGATION_PARAMS,\n} from './icStorage';\nimport { Wallet } from '@astrox/sdk-core';\n\nimport { AbstractedClientStorage } from '@astrox/sdk-core';\n\nexport class AuthClient {\n  public static async create(\n    options: AuthClientCreateOptions = {\n      appId: '',\n    },\n  ): Promise<AuthClient> {\n    const storage = options.storage ?? new ICStorage('astrox-');\n\n    let key: null | SignIdentity = null;\n    if (options.identity) {\n      key = options.identity;\n    } else {\n      const maybeIdentityStorage = await storage.get(KEY_ICSTORAGE_KEY);\n\n      if (maybeIdentityStorage) {\n        try {\n          key = Ed25519KeyIdentity.fromJSON(maybeIdentityStorage);\n        } catch (e) {\n          // Ignore this, this means that the ICStorage value isn't a valid Ed25519KeyIdentity\n          // serialization.\n        }\n      }\n    }\n\n    let identity = new AnonymousIdentity();\n    let chain: null | DelegationChain = null;\n    let wallet: Wallet | undefined = undefined;\n    let delegationTargets: string[] = [];\n    let lastRequest: InternetIdentityAuthRequest | undefined = undefined;\n    let confirm = true;\n    let delegationIdentity: DelegationIdentity | undefined = undefined;\n    if (key) {\n      try {\n        const chainStorage = await storage.get(KEY_ICSTORAGE_DELEGATION);\n        let walletString = await storage.get(KEY_ICSTORAGE_WALLET);\n        if (walletString) {\n          wallet = JSON.parse(walletString);\n        }\n        if (chainStorage) {\n          chain = DelegationChain.fromJSON(chainStorage);\n          chain.delegations.forEach(signedDelegation => {\n            const targets =\n              signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0 ? signedDelegation.delegation.targets : undefined;\n            if (targets) {\n              delegationTargets = [...new Set(delegationTargets.concat(targets.map(e => e.toText())))];\n            }\n          });\n          // Verify that the delegation isn't expired.\n          if (!isDelegationValid(chain)) {\n            await _deleteStorage(storage);\n            key = null;\n          } else {\n            identity = DelegationIdentity.fromDelegation(key, chain);\n          }\n        }\n      } catch (e) {\n        console.error(e);\n        // If there was a problem loading the chain, delete the key.\n        await _deleteStorage(storage);\n        key = null;\n      }\n    }\n    let delegationParams: AuthRequestJSON | undefined;\n    const delegationParamsString = await storage.get(KEY_DELEGATION_PARAMS);\n    if (delegationParamsString) {\n      delegationParams = JSON.parse(delegationParamsString) as AuthRequestJSON;\n      lastRequest = {\n        ...delegationParams.lastRequest,\n        maxTimeToLive: delegationParams.lastRequest.maxTimeToLive !== undefined ? BigInt(delegationParams.lastRequest.maxTimeToLive) : undefined,\n      };\n      confirm = delegationParams.confirm;\n      delegationIdentity = DelegationIdentity.fromDelegation(key!, chain!);\n    }\n\n    const ret = new this(\n      identity,\n      key,\n      chain,\n      storage,\n      wallet,\n      options.appId,\n      delegationIdentity,\n      delegationTargets,\n      lastRequest,\n      confirm,\n      options.idpWindowOption,\n    );\n    // ret.setDelegationTargets(delegationTargets);\n    return ret;\n  }\n\n  protected constructor(\n    private _identity: Identity,\n    private _key: SignIdentity | null,\n    private _chain: DelegationChain | null,\n    private _storage: AbstractedClientStorage,\n    private _wallet?: Wallet,\n    private _appId?: string,\n    private _delegationIdentity?: DelegationIdentity,\n    private _delegationTargets: string[] = [],\n    private _lastRequest?: InternetIdentityAuthRequest,\n    private _confirm?: boolean,\n    private _idpWindowOption?: string,\n    // A handle on the IdP window.\n    private _idpWindow?: Window,\n    // The event handler for processing events from the IdP.\n    private _eventHandler?: (event: MessageEvent) => void,\n  ) { }\n\n  private async _handleSuccess(message: AuthResponseSuccess, onSuccess?: () => void | Promise<void>): Promise<AuthClient> {\n    // console.log(message[\"identity\"]);\n    if ((message as MeAuthResponseSuccess)['identity'] !== undefined) {\n      const idDelegations = ((message as MeAuthResponseSuccess)['identity'] as DelegationResult).delegations.map(signedDelegation => {\n        const targets =\n          signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0\n            ? signedDelegation.delegation.targets?.map(t => Principal.fromText(t))\n            : undefined;\n        if (targets) {\n          this._delegationTargets = [...new Set(this._delegationTargets.concat(targets.map(e => e.toText())))];\n        }\n        return {\n          delegation: new Delegation(signedDelegation.delegation.pubkey.buffer, signedDelegation.delegation.expiration, targets),\n          signature: signedDelegation.signature.buffer as Signature,\n        };\n      });\n\n      const idDelegationChain = DelegationChain.fromDelegations(\n        idDelegations,\n        ((message as MeAuthResponseSuccess)['identity'] as DelegationResult).userPublicKey.buffer as DerEncodedPublicKey,\n      );\n      this._chain = idDelegationChain;\n      this._wallet = (message as MeAuthResponseSuccess)['wallet'];\n      this._confirm = (message as MeAuthResponseSuccess)['confirm'];\n    } else {\n      const iiDelegations = (message as DelegationResult).delegations.map(signedDelegation => {\n        const targets =\n          signedDelegation.delegation.targets && signedDelegation.delegation.targets.length > 0\n            ? signedDelegation.delegation.targets?.map(t => Principal.fromText(t))\n            : undefined;\n        if (targets) {\n          this._delegationTargets = [...new Set(this._delegationTargets.concat(targets.map(e => e.toText())))];\n        }\n        return {\n          delegation: new Delegation(signedDelegation.delegation.pubkey.buffer, signedDelegation.delegation.expiration, targets),\n          signature: signedDelegation.signature.buffer as Signature,\n        };\n      });\n\n      const iiDelegationChain = DelegationChain.fromDelegations(\n        iiDelegations,\n        (message as DelegationResult).userPublicKey.buffer as DerEncodedPublicKey,\n      );\n      this._chain = iiDelegationChain;\n    }\n\n    const key = this._key;\n    if (!key) {\n      return this;\n    }\n    this._delegationIdentity = DelegationIdentity.fromDelegation(key, this._chain!);\n    this._identity = this._delegationIdentity;\n    this._idpWindow?.close();\n    await onSuccess?.();\n    this._removeEventListener();\n    return this;\n  }\n\n  public getIdentity(): Identity {\n    return this._identity;\n  }\n\n  public getLastRequest(): InternetIdentityAuthRequest | undefined {\n    return this._lastRequest;\n  }\n\n  public getDelegationIdentity(): DelegationIdentity | undefined {\n    return this._delegationIdentity;\n  }\n\n  public getInnerKey(): SignIdentity | null {\n    return this._key;\n  }\n\n  public getDelegationChain(): DelegationChain | null {\n    return this._chain;\n  }\n\n  public get wallet(): Wallet {\n    return this._wallet!;\n  }\n  public getConfirm(): boolean | undefined {\n    return this._confirm;\n  }\n\n  public setWallet(data: Wallet): void {\n    this._wallet = data;\n  }\n\n  public getDelegateTargets(): string[] {\n    return this._delegationTargets;\n  }\n\n  public setDelegationTargets(targets: string[]): void {\n    this._delegationTargets = [...new Set(this._delegationTargets.concat(targets))];\n  }\n\n  public async isAuthenticated(): Promise<boolean> {\n    return !this.getIdentity().getPrincipal().isAnonymous() && this._chain !== null;\n  }\n\n  public async login(options?: AuthClientLoginOptions): Promise<void> {\n    let key = this._key;\n    if (!key) {\n      // Create a new key (whether or not one was in storage).\n      key = Ed25519KeyIdentity.generate();\n      this._key = key;\n      await this._storage.set(KEY_ICSTORAGE_KEY, JSON.stringify(key));\n    }\n\n    // Create the URL of the IDP. (e.g. https://XXXX/#authorize)\n    const identityProviderUrl = new URL(options?.identityProvider?.toString() || IDENTITY_PROVIDER_DEFAULT);\n    // Set the correct hash if it isn't already set.\n    identityProviderUrl.hash = IDENTITY_PROVIDER_ENDPOINT;\n\n    // If `login` has been called previously, then close/remove any previous windows\n    // and event listeners.\n    this._idpWindow?.close();\n    this._removeEventListener();\n\n    // Open a new window with the IDP provider.\n    this._idpWindow = window.open(identityProviderUrl.toString(), 'idpWindow', this._idpWindowOption) ?? undefined;\n    // Add an event listener to handle responses.\n\n    return new Promise((resolve, reject) => {\n      this._eventHandler = this._getEventHandler(identityProviderUrl, resolve, reject, options);\n      window.addEventListener('message', this._eventHandler);\n    });\n  }\n\n  private _getEventHandler(\n    identityProviderUrl: URL,\n    resolve: (value: any) => void,\n    reject: (reason?: any) => void,\n    options?: AuthClientLoginOptions,\n  ): EventHandler {\n    return async (event: MessageEvent) => {\n      if (event.origin !== identityProviderUrl.origin) {\n        return;\n      }\n\n      const message = event.data as IdentityServiceResponseMessage;\n\n      switch (message.kind) {\n        case 'authorize-ready': {\n          // IDP is ready. Send a message to request authorization.\n          const request: InternetIdentityAuthRequest =\n            options?.authType === 'authorize-append' && this._lastRequest\n              ? {\n                ...this._lastRequest,\n                delegationTargets: options?.delegationTargets ?? [],\n                sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer()!),\n                kind: 'authorize-append',\n              }\n              : {\n                kind: 'authorize-client',\n                sessionPublicKey: new Uint8Array(this._key?.getPublicKey().toDer()!),\n                maxTimeToLive: options?.maxTimeToLive,\n                permissions: options?.permissions ?? [PermissionsType.identity],\n                delegationTargets: options?.delegationTargets ?? [],\n                delegationModes: options?.delegationModes,\n                appId: this._appId,\n                noUnify: options?.noUnify,\n                host: options?.customDomain || options?.host,\n              };\n          this._lastRequest = request;\n          this._idpWindow?.postMessage(request, identityProviderUrl.origin);\n          break;\n        }\n        case 'authorize-client-success':\n          // Create the delegation chain and store it.\n          try {\n            resolve(await this._handleSuccess(message, options?.onSuccess));\n\n            // Setting the storage is moved out of _handleSuccess to make\n            // it a sync function. Having _handleSuccess as an async function\n            // messes up the jest tests for some reason.\n            // todo: targets tojson\n            if (this._chain) {\n              await this._storage.set(KEY_ICSTORAGE_DELEGATION, JSON.stringify(this._chain.toJSON()));\n            }\n            if (this._wallet !== undefined) {\n              await this._storage.set(KEY_ICSTORAGE_WALLET, JSON.stringify(this._wallet));\n            }\n            if (this._lastRequest !== undefined) {\n              const params = {\n                lastRequest: {\n                  ...this._lastRequest,\n                  maxTimeToLive: this._lastRequest.maxTimeToLive?.toString(),\n                },\n                confirm: this._confirm,\n              };\n              await this._storage.set(KEY_DELEGATION_PARAMS, JSON.stringify(params));\n            }\n          } catch (err) {\n            reject(this._handleFailure((err as Error).message, options?.onError));\n          }\n          break;\n        case 'authorize-client-failure':\n          reject(this._handleFailure(message.text, options?.onError));\n          break;\n        default:\n          break;\n      }\n    };\n  }\n\n  private _handleFailure(errorMessage?: string, onError?: (error?: string) => void): string | undefined {\n    this._idpWindow?.close();\n    onError?.(errorMessage);\n    this._removeEventListener();\n    return errorMessage;\n  }\n\n  private _removeEventListener() {\n    if (this._eventHandler) {\n      window.removeEventListener('message', this._eventHandler);\n    }\n    this._eventHandler = undefined;\n  }\n\n  public async logout(options: { returnTo?: string } = {}): Promise<void> {\n    _deleteStorage(this._storage);\n\n    // Reset this auth client to a non-authenticated state.\n    this._identity = new AnonymousIdentity();\n    this._key = null;\n    this._chain = null;\n    this._delegationTargets = [];\n    this._wallet = undefined;\n    this._delegationIdentity = undefined;\n    this._lastRequest = undefined;\n    this._confirm = undefined;\n\n    if (options.returnTo) {\n      try {\n        window.history.pushState({}, '', options.returnTo);\n      } catch (e) {\n        window.location.href = options.returnTo;\n      }\n    }\n  }\n}\n\n//\n"],"names":["AnonymousIdentity","Principal","Delegation","DelegationChain","DelegationIdentity","Ed25519KeyIdentity","isDelegationValid","PermissionsType","IDENTITY_PROVIDER_DEFAULT","IDENTITY_PROVIDER_ENDPOINT","KEY_ICSTORAGE_DELEGATION","KEY_ICSTORAGE_KEY","KEY_ICSTORAGE_WALLET","ICStorage","_deleteStorage","KEY_DELEGATION_PARAMS","AuthClient","create","options","appId","storage","key","identity","maybeIdentityStorage","get","fromJSON","e","chain","wallet","undefined","delegationTargets","lastRequest","confirm","delegationIdentity","chainStorage","walletString","JSON","parse","delegations","forEach","signedDelegation","targets","delegation","length","Set","concat","map","toText","fromDelegation","console","error","delegationParams","delegationParamsString","maxTimeToLive","BigInt","ret","idpWindowOption","_identity","_key","_chain","_storage","_wallet","_appId","_delegationIdentity","_delegationTargets","_lastRequest","_confirm","_idpWindowOption","_idpWindow","_eventHandler","_handleSuccess","message","onSuccess","idDelegations","t","fromText","pubkey","buffer","expiration","signature","idDelegationChain","fromDelegations","userPublicKey","iiDelegations","iiDelegationChain","close","_removeEventListener","getIdentity","getLastRequest","getDelegationIdentity","getInnerKey","getDelegationChain","getConfirm","setWallet","data","getDelegateTargets","setDelegationTargets","isAuthenticated","getPrincipal","isAnonymous","login","generate","set","stringify","identityProviderUrl","URL","identityProvider","toString","hash","window","open","Promise","resolve","reject","_getEventHandler","addEventListener","event","origin","kind","request","authType","sessionPublicKey","Uint8Array","getPublicKey","toDer","permissions","delegationModes","noUnify","host","customDomain","postMessage","toJSON","params","err","_handleFailure","onError","text","errorMessage","removeEventListener","logout","returnTo","history","pushState","location","href"],"mappings":"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"}